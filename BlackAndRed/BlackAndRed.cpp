#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <climits>
#include <cmath>

using namespace std;

//g++ BlackAndRed.cpp -o BlackAndRed
//./BlackAndRed



/*

Problem (1) BlackAndRed:
Initial thoughts:

As the question given a string of representative cards, 

when my program cut, then my program should return the number of cards I should remove from the top of the deck.

 "R" means red card and "B" means black card. So I have to create a variable to indicate which type is more.

And the the smallest number of red card mean the number of cards you should remove from the top of the deck



Pseudo-Code:

class BlackAndRed {
    public procedure cut(string deck) {
        int res = 0;
        int minpoint = 0;
        int point = 0;
        NodeFactor f;
        f.deck=deck;
        DP dp;
        Node n(0,deck.size(),f,f,f);
        n.BaseUpdate();
        NodeFactor base=dp.Solution(1, n);
        return base.value;
    endprocedure
endclass;

Reflection:

This problem is definitely to find a small possibility because you have to find the ratio between red and back card.

 and then we need to check the changing, and then we need to find out how many red cards are more than black cards.

If I want to improve the performance, I would like to choose brute force.



*/



// split, auto generated by FileEdit
vector<string> split( const string& s, const string& delim =" " ) {
    vector<string> res;
    string t;
    for ( int i = 0 ; i != s.size() ; i++ ) {
        if ( delim.find( s[i] ) != string::npos ) {
            if ( !t.empty() ) {
                res.push_back( t );
                t = "";
            }
        } else {
            t += s[i];
        }
    }
    if ( !t.empty() ) {
        res.push_back(t);
    }
    return res;
}

vector<int> splitInt( const string& s, const string& delim =" " ) {
    vector<string> tok = split( s, delim );
    vector<int> res;
    
    for ( int i = 0 ; i != tok.size(); i++ )
        res.push_back( atoi( tok[i].c_str() ) );
    return res;
}
// split, auto generated by FileEdit

// BEGIN CUT HERE
#define ARRSIZE(x) (sizeof(x)/sizeof(x[0]))

template<typename T> void print( T a ) {
    cerr << a;
}
static void print( long long a ) {
    cerr << a << "L";
}
static void print( string a ) {
    cerr << '"' << a << '"';
}
template<typename T> void print( vector<T> a ) {
    cerr << "{";
    for ( int i = 0 ; i != a.size() ; i++ ) {
        if ( i != 0 ) cerr << ", ";
        print( a[i] );
    }
    cerr << "}" << endl;
}
template<typename T> void eq( int n, T have, T need ) {
    if ( have == need ) {
        cerr << "Case " << n << " passed." << endl;
    } else {
        cerr << "Case " << n << " failed: expected ";
        print( need );
        cerr << " received ";
        print( have );
        cerr << "." << endl;
    }
}
template<typename T> void eq( int n, vector<T> have, vector<T> need ) {
    if( have.size() != need.size() ) {
        cerr << "Case " << n << " failed: returned " << have.size() << " elements; expected " << need.size() << " elements.";
        print( have );
        print( need );
        return;
    }
    for( int i= 0; i < have.size(); i++ ) {
        if( have[i] != need[i] ) {
            cerr << "Case " << n << " failed. Expected and returned array differ in position " << i << ".";
            print( have );
            print( need );
            return;
        }
    }
    cerr << "Case " << n << " passed." << endl;
}
static void eq( int n, string have, string need ) {
    if ( have == need ) {
        cerr << "Case " << n << " passed." << endl;
    } else {
        cerr << "Case " << n << " failed: expected ";
        print( need );
        cerr << " received ";
        print( have );
        cerr << "." << endl;
    }
}
// END CUT HERE

/************** Program  Begin *********************/

class NodeFactor{
public:
    int i;
    string deck;
    int p;
    int mp;
    int value;
    NodeFactor(){
        i=0;
        deck="";
        p=0;
        mp=0;
        value=0;
    }
    bool lessthan(){
        return (p < mp)? true :false;
    }
    void F(int i){
        update(i);
        if (lessthan()) {
            mp = p;
            value = i + 1;
        }
    }
    void update(int i){
        if (deck[i]=='R') {
            p-=1;
        } else {
            p+=1;
        }
    }
};

class Node{
    int _i=0;
    int _min;
    int _max;
    NodeFactor _factor;
    NodeFactor _base;
    NodeFactor _data;
public:
    Node(){
        _i=0;
        _min=0;
        _max=0;
        _factor;
        _base;
        _data;
    }
    Node(int min,int max,NodeFactor factor,NodeFactor base,NodeFactor data){
        _min=min;
        _max=max;
        _factor=factor;
        _base=base;
        _data=data;
    }
    NodeFactor get(){
        if(_i<_min || _i>_max)
            return _base;
        else{
            _data.F(_i);
            _factor=_data;
            _base=_data;
            
        }
        return _base;
        //return (_i % _factor==0)?1:0;;
    }
    void setMin(int min){
        _min=min;
    }
    int getMin(){
        return _min;
    }
    int getMax(){
        return _max;
    }
    NodeFactor getFactor(){
        return _factor;
    }
    void setI(int i){
        _i=i;
    }
    void BaseUpdate(){
        get();
    }
    NodeFactor getBase(){
        return _base;
    }
    void setData(NodeFactor data){
        _data=data;
    }
    NodeFactor getData(){
        return _data;
    }
    bool end(){
        if(_i>_max)
            return true;
        return false;
    }
};

class DP{
public:
    
    std::map<int, Node> store;
    NodeFactor Solution(int i,Node n){
        NodeFactor result;
        int len=n.getMax()-i;
        int def_len=1;
        if(len<def_len){
            result= DecisionTree(i,n).getData();
        }else{
            int turn=0;
            for(int x=i;x<n.getMax();x++){
                Node nr(x,x,n.getFactor(),n.getBase(),n.getData());
                nr.setI(x);
                nr.BaseUpdate();
                n.setData(nr.getData());
                result=nr.getData();
                turn+=1;
            }
            
        }
        return result;
    }
    Node DecisionTree(int i,Node n){
        if (n.end()){
            return n;
        }
        else if (store.find(i)!= store.end()) {
            return (Node) store[i];
        }else{
            Node next(n.getMin(),n.getMax(),n.getFactor(),n.getBase(),n.getData());
            next.setI(i+1);
            next.BaseUpdate();
            
            Node result = DecisionTree(i+1,next);
            store[i]=result;
            return result;
        }
    }
};

class BlackAndRed {
public:
    int cut(string deck) {
        int res = 0;
        int minpoint = 0;
        int point = 0;
        NodeFactor f;
        f.deck=deck;
        DP dp;
        Node n(0,deck.size(),f,f,f);
        n.BaseUpdate();
        NodeFactor base=dp.Solution(1, n);
        return base.value;
    }
};

/************** Program End ************************/

// BEGIN CUT HERE
int main( int argc, char* argv[] ) {

    {
        BlackAndRed theObject;
        eq(0, theObject.cut("BRBRBR"),0);
    }

    
    {
        BlackAndRed theObject;
        eq(1, theObject.cut("RBRBRB"),1);
    }

    {
        BlackAndRed theObject;
        eq(2, theObject.cut("BBBRRRRB"),7);
    }
    {
        BlackAndRed theObject;
        eq(3, theObject.cut("BR"),0);
    }
    {
        BlackAndRed theObject;
        eq(4, theObject.cut("RBRBBRRRRBBBRBBRRBRBBRRRBRBBBRBRBRBRBRRB"),9);
    }

    return 0;
}
// END CUT HERE
